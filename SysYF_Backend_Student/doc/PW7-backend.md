- [运行时空间管理与代码生成（选做）](#运行时空间管理与代码生成选做)
  - [参考文档](#参考文档)
  - [简介](#简介)
  - [实验内容](#实验内容)
    - [任务1：寄存器分配](#任务1寄存器分配)
    - [任务2：Phi指令生成——数据移动](#任务2phi指令生成数据移动)
    - [实验提示](#实验提示)
    - [任务3：栈空间分配](#任务3栈空间分配)
  - [思考题](#思考题)
  - [其他](#其他)

## 运行时空间管理与代码生成（选做）

> 负责助教：王原龙，陈金宝

### 参考文档
[汇编指令相关数据结构定义接口](AsmValue.md)
在后端中，所有的位置（寄存器、立即数、栈地址等）使用助教提供的接口进行表示。

[栈帧结构与ABI约定](StackFrameAndABI.md)
在[栈空间分配](##栈空间分配)实验中你需要按照约定进行栈空间分配。

### 简介
LLVM IR虽然是一个整体而言靠近底层的中间表示，但是它仍有一些较为理想的假设和高层的语义，需要在代码生成阶段处理，包括
- 无限的虚拟寄存器
- Phi指令
- ...

无限寄存器的假设使得LLVM IR的代码不需要进行太多运行时的空间管理，比如栈的维护、临时寄存器的现场保存、汇编ABI接口的满足（如函数传参约定），所以在代码生成中需要添加这些部分的内容与相关信息的维护。
Phi指令虽然给代码优化过程提供了很多方便，但它的语义是非常高级的语义，它要求在代码执行的过程中感知代码执行路径，同时一个基本块开头的Phi指令并行执行，这基本没有硬件支持的基础，所以代码生成阶段要通过各种手段消除Phi指令。在本次实验中，Phi指令的消除方法是在代码生成阶段直接按照Phi指令的语义生成相关的数据移动代码。具体而言，对于中级IR（LLVM 兼容），每个基本块至多有两个后继，所以当执行到这个基本块的末尾，需要为它即将跳转到的基本块开头的Phi指令完成数据的移动，这部分代码在当前基本块末尾产生。对于有两个后继的分支跳转，可以使用ARM的条件执行指令产生代码，如下所示：
```
//code in LLVM IR
l0:
%3 = icmp ne i32 %1, i32 %2
br i1 %3, label %l1, label %l2

l1:
%4 = phi i32 [%1, %l0], [0, %l3]
...

l2:
%5 = phi i32 [%2, %l0], [1, %l3]
...


//code in asm, assume that %1->r1, %2->r2, ...
l0:
    cmp r1, r2
    movne r4, r1
    bne l1
    mov r5, r2
    b l2
...
```

### 实验内容
实验之前请[阅读文档](#参考文档)，了解本实验框架给出的数据结构接口。
本实验各个部分之间是相辅相成的，寄存器分配时候的策略（分配哪些寄存器，保留哪些寄存器）和栈空间的分配将直接影响后面实现的难易，同学们可以在这个过程中体会不同的设计选择之间的互相影响。

#### 任务1：寄存器分配
在本部分，你需要补全一个线性扫描的寄存器分配算法。详情见[寄存器分配实验文档](RegAlloc.md)

#### 任务2：Phi指令生成——数据移动
本实验框架提供的代码对于Phi指令的处理正如前面所述，需要你实现的是数据移动部分的代码，请在`{WorkSpace}/src/CodeGen/DataMoving.cpp`文件中补全`data_move`函数，它的定义如下：
- 参数`src`表示数据来源，它是一系列数据来源位置组成的`vector`，数据来源可能是立即数、寄存器或者栈上的地址；
- 参数`dst`表示数据目的地，它是一系列数据目的位置组成的`vector`，可能是寄存器或者栈地址，与`src`等长，源和目的按照在容器中的位置相对应；
- 参数`cmpop`表示条件执行所需条件，你编写的数据移动函数生成的所有数据指令都需要使用此条件执行

在实现过程中，你需要注意：
- 来源和目的有可能包含相同的寄存器或栈地址，但不一定是对应的，比如可能有如下输入：
  ```
  src = {r1,r2,r3}
  dst = {r2,r3,r1}
  ```
  按照Phi指令的语义，这些移动应该是并行执行，也就是说移动后 r1, r2, r3 三个寄存器中装的分别是 r3, r1, r2 在移动之前的值。你需要想办法解决这里的依赖问题，这也是这部分实验的重点。**欢迎各种奇思妙想**。
- 数据来源可能有重复，但目的地不会重复，来源有重复时，**寄存器和常数将是`IR2asm::RegLoc`类的不同对象，而栈地址将是`IR2asm::RegBase`的相同对象**，这是由于准备数据来源的时候没有检查是否重复，但栈地址是直接从`stack_map`中读出，所以相同的栈地址对应的是同一个对象。
- 对于有两个后继的基本块，本实验框架给出的Phi指令生成将会在分支指令成功和失败的跳转之前分别调用一次你写的数据移动函数，并传入条件执行所需要的条件，你不需要处理条件执行部分。
- 本实验框架已给出单个数据的移动代码(`single_data_move`)，它将单个源位置的数据移动到目的位置，同时附加条件码，你需要传入一个临时寄存器以完成将常数存入栈位置或将栈上数据移动到栈上另一位置。由于不做临时寄存器保护，当使用临时寄存器时`single_data_move`将**破坏临时寄存器的值**。
- 在本实验框架实现的代码生成部分，被调用者会在被调用时保存`lr`寄存器，退出前恢复`lr`寄存器的值，所以你可以使用`lr`，但是`single_data_move`有可能破坏`lr`寄存器的值（不论你传进什么临时寄存器），如果你要使用`lr`寄存器，请记得保存。

#### 实验提示
- 需要防止破坏临时寄存器里的值，除非你确信这个寄存器是没用的，所以你可以在寄存器分配阶段就直接预留临时寄存器不分配出去。但是这种做法将导致可用寄存器变少，增大栈空间，而栈的数据移动是有些麻烦和费时的。
- 充分利用栈，这是一个非常大的连续内存空间，所以一个实现上简单处理数据相关的方法是把源全都压到栈上再逐个放到目的中去。这当然会产生性能损失，但因为本实验没有性能要求，所以用这种方法也是可以接受的。但我们仍希望你开动脑筋，尽力提高这部分的性能。

#### 任务3：栈空间分配
由于LLVM IR有无限的虚拟寄存器，所以并没有显式地处理栈相关的操作，只是使用`alloca`来进行空间的分配。然而，实际体系结构中寄存器的数目是有限的，所以需要把一些寄存器放不下的内容溢出到栈上（包括数组）。
你需要在`{WorkSpace}/src/CodeGen/StackAlloc.cpp`中实现栈空间分配的代码，请确保完成阅读[文档](#参考文档)后再写这部分代码，此函数以`Function*`为参数，代表待处理的函数，它的接口与你们之前实验的接口一致，通过这个指针你可以获得待处理函数的各种信息（如各个参数的信息、参数个数）。函数返回分配的总空间的大小（字节数）。

你需要注意：
- 寄存器分配产生的`reg_map`可以直接使用，它就是你在寄存器分配的时候生成的`reg_map`，你需要为其中`reg_num`为 -1 的`interval`分配栈空间，以`IR2asm::RegBase`给出其基地址，存入`stack_map`当中。
- 同时，通过栈传递的函数参数在栈上的位置（如ABI约定）还要保存到`arg_on_stack`当中，不论它是否被分配了寄存器。
- 你可以通过`bool have_temp_reg`和`bool have_func_call`来判断此函数是否使用临时寄存器以及内部是否有函数调用，它们都是`CodeGen`类的数据域。
- 类似的，你可以通过`int caller_saved_reg_num`和`int temp_reg_store_num`获得调用者保存的寄存器个数以及临时寄存器暂存空间的大小，通过`const int reg_size`来获得寄存器的字节数，它们都是`CodeGen`类的数据域并且已经在调用栈分配之前维护好。
- 注意函数形参的空间分配，有些参数通过栈传递，已经拥有了栈空间，不必重新分配。
- 局部数组并不在`reg_map`中，而是在开始块中通过`alloca`语句分配空间，所以你还需要遍历`fun->get_entry_block()->get_instructions()`，根据其中的`alloca`语句进行空间分配。
- 理论上讲你甚至可以将所有变量在寄存器分配阶段全部溢出到栈，这将使得寄存器分配的代码非常简单，但是代码将经历大量内存操作，这也属于设计选择互相影响的范畴。但是这种写法视为未完成寄存器分配。

### 思考题

请在[answer.md](answer.md)中回答：

1. 由于指令长度有限，所以指令的立即数是有范围的。请查阅相关资料，了解在ARM 的代码生成中如何处理超范围立即数问题，并在[answer.md](answer.md)中进行说明。
2. 在本实验框架给出的IR实现中，可以通过强制给phi指令涉及到的所有虚寄存器分配相同的物理寄存器（或栈地址）来规避phi指令移动吗，为什么？
3. 如何在寄存器分配的时候结合函数调用ABI以及Phi指令的要求产生更高效率的代码？

### 其他

在本实验中你无需考虑float。



